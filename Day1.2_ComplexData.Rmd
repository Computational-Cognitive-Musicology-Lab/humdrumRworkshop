---
title: "Dealing with Complex data"
subtitle: "Georgia Tech, humdrumR Workshop"
author: "Nat Condit-Schultz"
date: "May 11, 2023"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    theme: flatly
---

```{r}
library(humdrumR)
```


The humdrum syntax is very flexible. There are lots of ways that data can be organized.

+ We can have multiple aspects of musical scrunched into single strings (`"[4.ee-/JJ"`]).
+ Or we can spread information across...
  + multiple spines
  + spine paths
  + multi-stops
+ We can also put information into tandem interpretations...

When dealing with humdrum data, we have to figure out how to make sense of any of these possibilities.
There is no general solution that humdrumR can automatically do for you!

----


When humdrumR reads in humdrum data, it reads it into a structurally agnostic "flat" table.
Each and every token gets its own row.
Sometimes, this is confusing, and/or not what you want!



# Discarding Data

Let's consider the CoCoPops Billboard dataset:

```{r}
bb <- readHumdrum('CoCoPops-Billboard/.*hum')

```

Take a look at this dataset---many of the files are too big to fit on our screen!
Let's use `spines()`:

```{r}
interpretations(bb)


```


Our files have one to five pairs of `**kern` and `**silbe` spines, followed by `**harmony`, `chordsym`, `**phrase`...etc.
The first step in any humdrum analysis is to get rid of data we don't want---which of course depends on the analysis.
We can do this most effectively, by subsetting using the `Exclusive` field.


```{r}
subset(bb, Exclusive %in% c('kern', 'silbe', 'harmony')) |> removeEmptySpines() -> bb

bb

```


Ok, that's much more manegable!

# Folding data

Ok, we have our kern tokens (which include rhythm and pitch data), lyrics, and harmony.
But remember, at this point each and every token is it's own row in the humdrum table.
So the `Token` field includes both kern, silbe, and harmony, all together!
We probably want to link/align these data such that, for example, the notes and syllables are lined up in two sepate fields.
We call this "folding" the humdrum data.

Let's try it with the lyrics:

```{r}
bb <- foldExclusive(bb, 'silbe', 'kern')

```

The `**silbe` spines have been removed from `Token`, and moved over into a new field (`Silbe`).
Notice that each `**silbe` spine is paired with the adjacent `**kern` spine.

We can next do the same thing with the `**harmony` spine:


```{r}
bb <- foldExclusive(bb$Token, 'harmony', 'kern')

```

If there are more `**kern` spines than `**harmony` spines, the harmonies are duplicated!


---

We now have our lyrics, harmony, and kern all "aligned" for ideal analysis.
We might want to split the pitch and rhythm informnation:

```{r}
bb <- within(bb$Token, Kern <- kern(Token), Recip <- recip(untie(Token)))


```




## Ditto

You probably noticed that the harmony spine doesn't actually have chords aligned with every note.
If we want to "fill forward" data into subsequent null data tokens, we can use ditto:

```{r}
bb <- within(bb$Token, Harmony <- ditto(tertian(Harmony)))
```

## Tied Notes

```{r}

within(bb$Recip, untie(as.character(Recip)))

```
